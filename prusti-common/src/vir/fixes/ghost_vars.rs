// Â© 2019, ETH Zurich
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Fix ghost variables.

use std::collections::HashMap;
use std::mem;

use super::super::ast;
use super::super::cfg;

/// Viper has a consistency check that only variables declared inside
/// the package statement can be assigned in it. Since these ghost
/// variables are generated by method calls that happen outside the
/// package statement, it is hard to satisfy this requirement when
/// creating the encoding. Therefore, we fix this with an additional
/// pass that renames all variables declared inside package statements
/// so that they are unique.
pub fn fix_ghost_vars(
    mut method: cfg::CfgMethod
) -> cfg::CfgMethod {
    // TODO: Renaming variables interferes with let-bindings around magic wands. For example:
    //    package [lhs1] --* ([lhs2] --* x == 0) {
    //      var x: Int := 0
    //      package [lhs] --* x == 0 { ... }
    //    }
    //  Renaming x in the package statement means that the outer magic wand cannot be packaged
    //  anymore, because the inner magic wand cannot be found due to the renamed variable.
    let mut fixer = GhostVarFixer::default();
    let mut sentinel_stmt = ast::Stmt::Comment(String::from("moved out stmt"));
    for block in &mut method.basic_blocks {
        for stmt in &mut block.stmts {
            mem::swap(&mut sentinel_stmt, stmt);
            sentinel_stmt = ast::StmtFolder::fold(&mut fixer, sentinel_stmt);
            mem::swap(&mut sentinel_stmt, stmt);
        }
    }
    method
}

#[derive(Default)]
struct GhostVarFixer {
    /// This is a stack of local variable replacements. The topmost mapping corresponds to the
    /// current package block, the next mapping corresponds to the parent package block, and so on.
    levels: Vec<HashMap<ast::LocalVar, ast::LocalVar>>,
}

impl GhostVarFixer {
    fn fix_variable(&mut self, var: ast::LocalVar) {
        if var.name.starts_with("et$") {
            // TODO: This variable is also used in a let-binding in the expiration tool. Renaming
            //  it would break everything. This should be done differently, but time is scarce.
            return
        }
        for level in &mut self.levels {
            if level.contains_key(&var) {
                return
            }
        }
        let current_level_index = self.levels.len();
        if let Some(current_level) = self.levels.last_mut() {
            let mut fixed_var = var.clone();
            fixed_var.name.push_str(&format!("$p{}", current_level_index));
            current_level.insert(var, fixed_var);
        }
    }
}

impl ast::StmtFolder for GhostVarFixer {
    fn fold_expr(&mut self, e: ast::Expr) -> ast::Expr {
        ast::ExprFolder::fold(self, e)
    }

    fn fold_assign(&mut self, p: ast::Expr, e: ast::Expr, k: ast::AssignKind) -> ast::Stmt {
        match &p {
            ast::Expr::Local(var, _) => self.fix_variable(var.clone()),
            _ => {},
        }
        ast::Stmt::Assign(self.fold_expr(p), self.fold_expr(e), k)
    }

    fn fold_package_magic_wand(
        &mut self,
        wand: ast::Expr,
        body: Vec<ast::Stmt>,
        label: String,
        vars: Vec<ast::LocalVar>,
        pos: ast::Position,
    ) -> ast::Stmt {
        let wand = self.fold_expr(wand);

        self.levels.push(HashMap::new());

        let body = body.into_iter().map(|stmt| self.fold(stmt)).collect();

        let fixed_vars = self.levels.pop().unwrap().into_iter()
            .map(|(_, fixed_var)| fixed_var);

        let vars = std::iter::empty().chain(vars).chain(fixed_vars).collect();
        ast::Stmt::PackageMagicWand(wand, body, label, vars, pos)
    }
}

impl ast::ExprFolder for GhostVarFixer {
    fn fold_local(&mut self, local_var: ast::LocalVar, pos: ast::Position) -> ast::Expr {
        let fixed_var = self.levels.iter().rev()
            .filter_map(|var_mapping| var_mapping.get(&local_var))
            .cloned()
            .next().unwrap_or(local_var);
        ast::Expr::Local(fixed_var, pos)
    }
}
